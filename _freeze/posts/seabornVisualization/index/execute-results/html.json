{
  "hash": "c2275da498f3b41b19f5e304ac83e6f7",
  "result": {
    "markdown": "---\ntitle: \"plotting in Python with Seaborn: Distribution plot\"\nauthor: \n  - name: Masumbuko Semba\n    url: https://semba.netlify.app\n    orcid: 0000-0002-5002-9747\n    affiliation: Nelson Mandela African Institution of Science and Technology\n    affiliation-url: https://semba.netlify.app/ \ndate: \"2023-02-21\"\ncategories: [Analysis, Visualization, Python]\nimage: \"displot.jpg\"\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\nbibliography: ../blog.bib\nexecute: \n  warning: false\nfig-width: 7\nfig-height: 5\ncode-line-numbers: true\n---\n\n\n## Introduction\n\nWikipedia [-@dataviz] describe data visualization as an interdisciplinary field that deals with the graphic representation of data and information. It is a particularly efficient way of communicating when the data are processed to generate information that is shared. \n\nIt is also the study of visual representations of abstract data to reinforce human cognition using common graphics, such as charts, plots, infographics, maps, and even animations. The abstract data include both numerical and non-numerical data, such as text and geographic information. \n\nFurthermore, it is related to infographics and scientific visualization to identify important patterns in the data that can be used for organizational decision making. Visualizing data graphically can reveal trends that otherwise may remain hidden from the naked eye.\n\nIn the following is the series of post that focuse plotting with seaborn library in Python, we will learn the most commonly used plots using Seaborn library  in Python [@waskom2021seaborn; @matplotlib]. We will also touches on different types of plots using Maplotlib [@matplotlib], and Pandas [@pandas] libraries. In this post we will focus on the distplot. \n\n## Loading libraries\n\nThough most people are familiar with plotting using matplot, as it inherited most of the functions from MatLab. Python has an extremely nady library for data visualiztion called seaborn. The Seaborn library is based on the Matplotlib library. Therefore, you will also need to import the Matplotlib library.\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport pandas as pd\nimport numpy as np\n\nsns.set_theme()\n```\n:::\n\n\n## Dataset\n\nWe are going to use a penguin dataset from palmerpenguins package [@horst2022palmer]. We first need to import the dataset from the package where is stored into the R session. let us load the packages that we are glint to use in this post.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npengr = palmerpenguins::penguins\npengr\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 344 x 8\n   species island    bill_length_mm bill_depth_mm flipper_~1 body_~2 sex    year\n   <fct>   <fct>              <dbl>         <dbl>      <int>   <int> <fct> <int>\n 1 Adelie  Torgersen           39.1          18.7        181    3750 male   2007\n 2 Adelie  Torgersen           39.5          17.4        186    3800 fema~  2007\n 3 Adelie  Torgersen           40.3          18          195    3250 fema~  2007\n 4 Adelie  Torgersen           NA            NA           NA      NA <NA>   2007\n 5 Adelie  Torgersen           36.7          19.3        193    3450 fema~  2007\n 6 Adelie  Torgersen           39.3          20.6        190    3650 male   2007\n 7 Adelie  Torgersen           38.9          17.8        181    3625 fema~  2007\n 8 Adelie  Torgersen           39.2          19.6        195    4675 male   2007\n 9 Adelie  Torgersen           34.1          18.1        193    3475 <NA>   2007\n10 Adelie  Torgersen           42            20.2        190    4250 <NA>   2007\n# ... with 334 more rows, and abbreviated variable names 1: flipper_length_mm,\n#   2: body_mass_g\n```\n:::\n:::\n\n\nOnce the tibble file is in the environment, we need to convert from tibble data frame into pandas dataframe. Make a copy of pandas dataframe from tibble with the `r.` function. please note that the conversion of tibble data frame to pandas data frame must be inside the Python chunk as chunk below;\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\npengp = r.pengr\n```\n:::\n\nLet's use `head` function to explore the first five rows on the converted penguin pandas data frame\n\n::: {.cell}\n\n```{.python .cell-code}\npengp.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  species     island  bill_length_mm  ...  body_mass_g     sex  year\n0  Adelie  Torgersen            39.1  ...         3750    male  2007\n1  Adelie  Torgersen            39.5  ...         3800  female  2007\n2  Adelie  Torgersen            40.3  ...         3250  female  2007\n3  Adelie  Torgersen             NaN  ...  -2147483648     NaN  2007\n4  Adelie  Torgersen            36.7  ...         3450  female  2007\n\n[5 rows x 8 columns]\n```\n:::\n:::\n\nThe pengp dataset comprise various measurements of three different penguin species --- Adelie, Gentoo, and Chinstrap. The dataset contains eight variables -- species, island, bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g, sex, and year. You do not need to download this dataset as it comes with the palmerpenguin library in R. We will use this dataset to plot some of the seaborn plots. Lets begin plotting\n\nAlternatively, you can load the package as\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\ndf = sns.load_dataset(\"penguins\")\ndf.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  species     island  bill_length_mm  ...  flipper_length_mm  body_mass_g     sex\n0  Adelie  Torgersen            39.1  ...              181.0       3750.0    Male\n1  Adelie  Torgersen            39.5  ...              186.0       3800.0  Female\n2  Adelie  Torgersen            40.3  ...              195.0       3250.0  Female\n3  Adelie  Torgersen             NaN  ...                NaN          NaN     NaN\n4  Adelie  Torgersen            36.7  ...              193.0       3450.0  Female\n\n[5 rows x 7 columns]\n```\n:::\n:::\n\n\n\n## Univariable distribution\n\nThe distplot, also commonly refers as the distribution plot, is widely used to plot a histogram of data for a specific variable in a dataset. To make this plot seaborn has a dedicated function called `displot`\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nfig = plt.figure()\nsns.displot(pengp.bill_length_mm)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=242}\n:::\n\n```{.python .cell-code}\nplt.xlabel(\"Bill length (mm)\")\nplt.ylabel(\"Frequency\")\nplt.show()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-2.png){width=480}\n:::\n:::\n\n\nThe new `displot` functions support the kernel density estimate line, by passing `kde=True`\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nfig = plt.figure()\nsns.displot(pengp.bill_length_mm, kde = True)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-5.png){width=242}\n:::\n\n```{.python .cell-code}\nplt.xlabel(\"Bill length (mm)\")\nplt.ylabel(\"Frequency\")\nplt.show()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-6.png){width=480}\n:::\n:::\n\n\nTo change the distribution from counts to density, we simply parse an argument `stat=\"density\"`\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nfig = plt.figure()\nsns.displot(pengp.bill_length_mm, kde = True, stat = \"density\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-9.png){width=242}\n:::\n\n```{.python .cell-code}\nplt.xlabel(\"Bill length (mm)\")\nplt.ylabel(\"Frequency\")\nplt.show()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-10.png){width=480}\n:::\n:::\n\n\n## kdeplot\nWhen you want to draw the density plot alone without overlay it to the histogram as presented using the displot function, seaboarn has a `kdeplot` function\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nfig = plt.figure()\nsns.kdeplot(pengp.bill_length_mm)\nplt.xlabel(\"Bill length (mm)\")\nplt.ylabel(\"Density\")\nplt.show()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-13.png){width=672}\n:::\n:::\n\n\ndisplot still can draw the kde plot, however, you need to parse an argument `kind=\"kde\"` in displot:\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nfig = plt.figure()\nsns.displot(pengp.bill_length_mm, kind = \"kde\", rug = True)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-15.png){width=242}\n:::\n\n```{.python .cell-code}\nplt.xlabel(\"Bill length (mm)\")\nplt.ylabel(\"Frequency\")\nplt.show()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-16.png){width=480}\n:::\n:::\n\nIf you parse `rug = True` function, wll  add the rug in the plots\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nfig = plt.figure()\nsns.displot(pengp.bill_length_mm, kind = \"kde\", rug = True)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-19.png){width=242}\n:::\n\n```{.python .cell-code}\nplt.xlabel(\"Bill length (mm)\")\nplt.ylabel(\"Frequency\")\nplt.show()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-20.png){width=480}\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\naa = pengp[[\"bill_length_mm\", \"bill_depth_mm\"]]\n\nfig = plt.figure()\nsns.kdeplot(data = aa)\nplt.xlabel(\"Bill length (mm)\")\nplt.ylabel(\"Frequency\")\nplt.show()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-23.png){width=672}\n:::\n:::\n\n\nPlot conditional distributions with hue mapping of a second variable. Unlike the previous plot, for this kind you need to specify the x-variable and the hue in the dataset;\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nfig = plt.figure()\nsns.kdeplot(data = pengp, x = \"bill_length_mm\", hue = \"species\")\nplt.xlabel(\"Bill length (mm)\")\nplt.ylabel(\"Frequency\")\nplt.show()\n\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-25.png){width=672}\n:::\n:::\n\n\n`Stack` the conditional distributions by simply parsing argument `multiple = \"stack\"`\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nfig = plt.figure()\nsns.kdeplot(data = pengp, x = \"bill_length_mm\", hue = \"species\", multiple = \"stack\")\nplt.xlabel(\"Bill length (mm)\")\nplt.ylabel(\"Frequency\")\nplt.show()\n\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-27.png){width=672}\n:::\n:::\n\n\n`multiple = \"fill\"` simply normalize the stacked distribution at each value in the grid\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nfig = plt.figure()\nsns.kdeplot(data = pengp, x = \"bill_length_mm\", hue = \"species\", multiple = \"fill\")\nplt.xlabel(\"Bill length (mm)\")\nplt.ylabel(\"Frequency\")\nplt.show()\n\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-29.png){width=672}\n:::\n:::\n\n\nEstimate the cumulative distribution function(s), normalizing each subset:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nfig = plt.figure()\n\nsns.kdeplot(data = pengp, x = \"bill_length_mm\", hue = \"species\",  cumulative=True, common_norm=False, common_grid=True)\nplt.xlabel(\"Bill length (mm)\")\nplt.ylabel(\"Frequency\")\nplt.show()\n\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-31.png){width=672}\n:::\n:::\n\n\n## Bivariate distribution\nFor bivariates, we are going to use `geyser` dataset. Old Faithful is a cone geyser in Yellowstone National Park in Wyoming, United States. It is a highly predictable geothermal feature and has erupted every 44 minutes to two hours since 2000. We do not need to download this dataset as it comes with the seaborn package.\n\n\n::: {.cell}\n\n```{.python .cell-code}\ngeyser = sns.load_dataset(\"geyser\")\ngeyser.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   duration  waiting   kind\n0     3.600       79   long\n1     1.800       54  short\n2     3.333       74   long\n3     2.283       62  short\n4     4.533       85   long\n```\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\nfig = plt.figure()\nsns.kdeplot(data=geyser, x=\"waiting\", y=\"duration\")\nplt.show()\n\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-33.png){width=672}\n:::\n:::\n\n\nMap a third variable with a hue semantic to show conditional distributions:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nfig = plt.figure()\nsns.kdeplot(data=geyser, x=\"waiting\", y=\"duration\", hue = \"kind\")\nplt.show()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-35.png){width=672}\n:::\n:::\n\n\nFill the contour by parsing `fill = True`\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nfig = plt.figure()\nsns.kdeplot(data=geyser, x=\"waiting\", y=\"duration\", hue = \"kind\", fill = True)\nplt.show()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-20-37.png){width=672}\n:::\n:::\n\n\nShow fewer contour levels, covering less of the distribution by parsing a `levels` and `thresh` functions in the kdeplot:\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n\nfig = plt.figure()\nsns.kdeplot(data=geyser, x=\"waiting\", y=\"duration\", hue = \"kind\", levels = 5, thresh = .2)\nplt.show()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-21-39.png){width=672}\n:::\n:::\n\n\n\n## Cited Materials\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}