{
  "hash": "8c64ff022cb48d6f35eb3de77bbd5fae",
  "result": {
    "markdown": "---\ntitle: \" Linear and Bayesian Regression Models with tidymodels package\"\nauthor: \n  - name: Masumbuko Semba\n    url: https://semba.netlify.app\n    orcid: 0000-0002-5002-9747\n    affiliation: Nelson Mandela African Institution of Science and Technology\n    affiliation-url: https://semba.netlify.app/ \ndate: \"2023-04-11\"\ncategories: [Manipulation,Visualization, R, Modelling]\ntags: \n  - tidymodels\n  - regression\n  - modelling\n  - Masumbuko Semba\n# image: \"thumbnail.jpg\"\ndraft: false # setting this to `true` will prevent your post from appearing on your listing page until you're ready!\nbibliography: ../blog.bib\ncsl:  ../apa.csl\nexecute: \n  warning: false\nfig-width: 7\nfig-height: 5\ncode-line-numbers: true\n---\n\n\n# Introduction\n\nWe live in age of increasing data and as a data scientist, our role primarily involves exploring and analyzing data. However, with the amount of data data exploration and analysis become a thing for automation and use of intelligent tools to help us glean key information from data. The results of an analysis might form the basis of a report or a machine learning model, but it all begins with data. The two popular tools commonly used are R and Python. R is one of the most popular programming languages for data scientists. R is an elegant environment that's designed to support data science, and you can use it for many purposes.\n\nAfter decades of open-source development, R provides extensive functionality that's backed by a massive set of powerful statistical modeling, machine learning, visualization and data wrangling packages. Some of these package that has revolutionized R are **tidyverse** and **tidymodel** package. **tidyverse** is a collection of R packages that make data science faster, easier, and more fun and **tidymodels** is a collection of R packages for modeling and statistical analysis.\n\nAs a data scientist, you need to distinguish between *regression predictive models* and *classification predictive models*.  Clear understanding of these models helps to choose the best one for a specific use case. In a nutshell, *regression predictive models*and *classification predictive models* fall under supervised machine learning. The main difference between these two models is the output: while in regression produce an output as numerical (or continuous), the output of classification is categorical (or discrete).\n\nA big part of machine learning is *classification* — we want to know what class or group an observation belongs to. Therefore, the ability to precisely classify observations to their groups is valuable for various business applications like predicting the future based on historical data. For example, when provided with a dataset about environmental variables, and you are asked to predict productivity, that is a regression task because productivity measured in term of chlorophyll concentration will be a continuous output.\n\nIn this post we will focus on regression. We will learn the steps of modelling using **tidymodels** [@tidymodels]. We first explore the data and check if it fit for modelling, we then split the dataset into a training and testing sets. Next, we will create a recipe object and define our model. Lastly, we will train a specified model and evaluate its performance. I will use the same dataset for three different model's algorithms. Example of the common regression algorithms include `random forest`, `linear regression`, `support vector regression (SVR)` and `bayes`. Some algorithms, such as `logistic regression`, have the name `regression` in their functions but they are not regression algorithms.\n\nTo follow use code in this article, you will need **tidymodels** [@tidymodels] and **tidyverse** packages [@tidyverse] installed in your machine. You can install them from CRAN. The chunk below highlight lines of code to install the packages if they are yet in your PC. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel.packages = c(\"tidymodels\", \"tidyverse\")\n\ninstall.packages(model.packages)\n```\n:::\n\n\nOnce installed, you can load the packages in your session. We often we use several packages to accomplish a task. Even in this post, though seems only two packages are loaded, these are ecosystems which  comes with dozens of packages bundled with them. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrequire(tidyverse)\nrequire(tidymodels)\n```\n:::\n\n\n\n# The dataset\nWe use the data collected with the Institute of Marine Sciences of the University of Dar es Salaam to illustrate the concept. The data was collected through the Coral Reef Targeted Research and Capacity Building for Management (CRTR) project between 2008 and 2009. The dataset contains;\n\n+ Chemical variables ---nitrate, phosphate, salinity, pH, dissolved oxygen and ammonia\n+ Physical variables --- temperature\n+ Biological variables--- chlorophyll-*a*\n\nBecause the variables are organized in sheets of Excel spreadsheet, i used a `read_excel` function from **readxl** package [@readxl] to read the file from the sheet. And because there are several sheet, the processed was iterated with a `for` loop. Data from each sheet was allocated in the list file. The chunk below highlight the code used to read files in sheets. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nvariables = c(\"salinity\", \"temperature\", \"do\", \"ph\", \"chl\", \"ammonia\", \"phosphate\", \"nitrate\")\n\ncrtr.list = list()\n\nfor (i in 1:length(variables)){\n  \n  crtr.list[[i]] = readxl::read_excel(\"../data/crtr.xlsx\", sheet = i) %>% \n    mutate(variable = variables[i]) \n\n}\n```\n:::\n\n\nThe data was untidy and unsuitable for visualization and modelling in R. Therefore, the first thing I had to deal with the data was to tidy the variables in the dataset to a right format that **tidymodels** and **tidyverse** recognizes. First the dataset was unlisted with `bind_rows` function and the data was pivoted to long format and then back to wide format with only the variable of interested selected. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## organize in long form\ncrtr.long = crtr.list %>% \n  bind_rows() %>%\n  pivot_longer(cols =2:5, names_to = \"sites\", values_to = \"data\" ) \n\n## organize in the wide form\ncrtr.wide = crtr.long %>%\n  pivot_wider(names_from = variable, values_from = data) %>%\n  mutate(month = lubridate::month(Date, label = TRUE, \n                                  abb = TRUE) %>% as.character()) %>%\n  mutate_if(is.character, as.factor) %>%\n  mutate_if(is.numeric, round, digits = 2)  %>%\n  select(date = Date, month,sites, chl, everything())\n```\n:::\n\n\nLet's us glimpse the dataset\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrtr.wide %>% \n  glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 52\nColumns: 11\n$ date        <dttm> 2008-03-01, 2008-03-01, 2008-03-01, 2008-03-01, 2008-04-0~\n$ month       <fct> Mar, Mar, Mar, Mar, Apr, Apr, Apr, Apr, May, May, May, May~\n$ sites       <fct> Pongwe, Mnemba, Chumbe, Bawe, Pongwe, Mnemba, Chumbe, Bawe~\n$ chl         <dbl> 0.09, 0.26, 0.56, 0.43, 0.47, 1.01, 0.63, 1.39, 0.37, 0.33~\n$ salinity    <dbl> 35.0, 34.0, 32.0, 32.0, 35.0, 35.0, 34.0, 34.0, 36.0, 36.0~\n$ temperature <dbl> 28.8, 28.4, 28.0, 28.0, 28.2, 27.7, 28.1, 26.7, 27.0, 27.2~\n$ do          <dbl> 6.11, 5.95, 6.16, NA, 6.35, 6.14, 7.01, 6.31, 6.15, 6.10, ~\n$ ph          <dbl> 7.86, 7.88, 7.73, NA, 7.87, 7.88, 7.86, 7.91, 7.68, 7.80, ~\n$ ammonia     <dbl> 0.55, 0.80, 0.74, 0.94, 0.56, 0.72, 0.53, 0.97, 0.56, 0.65~\n$ phosphate   <dbl> 0.28, 0.28, 1.31, 1.91, 0.28, 0.32, 1.16, 0.84, 0.28, 0.43~\n$ nitrate     <dbl> 0.04, 0.07, 3.26, 3.34, 0.03, 0.47, 1.45, 0.84, 0.06, 0.48~\n```\n:::\n:::\n\n\nAs a first step in modeling, it’s always a good idea to explore the variables in the dataset. @fig-fig0 is a pairplot that compare each pair of variables as scatterplots in the lower diagonal, densities on the diagonal and correlations written in the upper diagonal [@ggally]. @fig-fig1 show the correlation between chlorophyll-*a* (outcome) with other six predictor variables using a linear and quadratic equations is unfit for these dataset. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrtr.wide %>%\n  select(-salinity)%>%\n  mutate(season = lubridate::month(date) %>% as.integer(),\n         season = replace(season,season %in% c(1:4,11:12), \"NE\"),\n         season = replace(season,season %in% c(5:10), \"SE\"))%>%\n  GGally::ggscatmat(columns = 4:10,color=\"season\", alpha=1, corMethod = \"spearman\")+\n  ggsci::scale_color_jco()+\n  ggpubr::theme_pubclean()+\n  theme(strip.background = element_blank(), \n        legend.position = \"right\",\n        legend.key = element_blank())\n```\n\n::: {.cell-output-display}\n![Pair plot of numerical variables](index_files/figure-html/fig-fig0-1.png){#fig-fig0 width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwesa = wesanderson::wes_palettes %>% names()\n\ncrtr.wide %>%\n  select(-salinity)%>%\n  filter(nitrate < 1 & phosphate < 1.2 & chl < 1) %>% \n  pivot_longer(cols = 5:10, names_to = \"predictor\", values_to = \"data\") %>%\n  # filter(sites == \"Bawe\")%>%\n  ggplot(aes(x = data, y = chl))+\n  scale_y_continuous(trans = scales::sqrt_trans(), labels = function(x) round(x,2))+\n  # scale_x_continuous(trans = scales::sqrt_trans(), labels = function(x) round(x,2))+\n  geom_jitter()+\n  geom_smooth(se = FALSE, method = \"lm\", formula = \"y ~ poly(x,2)\", aes(color = \"Quadratic\"))+\n  geom_smooth(se = FALSE, method = \"lm\", formula = \"y ~ x\", aes(color = \"Linear\"))+\n   ggsci::scale_color_jco()+\n  facet_wrap(~predictor, scales = \"free_x\")+\n  ggpubr::theme_pubclean()+\n  theme(strip.background.x = element_blank(), legend.key = element_blank(), \n        legend.position = \"right\", panel.background = element_rect(colour = \"black\"))\n```\n\n::: {.cell-output-display}\n![Linear and quadratic correlation of environmental variables and chlorophyll-a](index_files/figure-html/fig-fig1-1.png){#fig-fig1 width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncrtr.clean = crtr.wide %>%\n  select(-salinity)%>%\n  filter(nitrate < 1 & phosphate < 1.2 & chl < 1)  %>%\n  select(-c(date:sites))\n```\n:::\n\n\n# Resample\n\nIn machine learning, one risk is the machine learns too well our sample data and is then less accurate during a real-world testing. This phenomenon is called *overtraining* or *overfitting*. We overcome this problem by splitting the dataset into a training and testing sets. The training set is used to train the model while the test set is reserved to later estimate how well the model might work on new or wild data. The splitting is based on ratios and the widely used ratios include 80/20, 75/25, or 7/30, with the training data receiving a bigger proportion of the dataset and the test set get the remaining small portion. \n\nFor our sample that has only 52 observations, it make sense to use 70/30 split ratio. we use the fraction `set.seed(4595)` from base R to fix the random number generator from **rsample** package [@rsample]. This prevent generating new data in each execution. the function `initial_split` from the **rsample** package is designed to split the dataset into a training and testing sets. We purse the data to be split and the proportion that serve as a cutpoint of the two sets. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(4595)\n\ncrtr.split = crtr.clean %>%\n  rsample::initial_split(prop = 0.7)\n\ncrtr.split\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<Analysis/Assess/Total>\n<28/13/41>\n```\n:::\n:::\n\n\nGiven the 41 total observations, we reserve 12 observations as a test set and kept 70% of the dataset (29 observation) as train set. From the `crtr.split` object, we pull both the train set with the `training` function and the test set with a `testing` function. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## pull train set\ncrtr.train = crtr.split %>% \n  training()\n\n## pull test set\ncrtr.test = crtr.split %>% \n  testing()\n```\n:::\n\n\nWe can have a glimpse of the train dataset using a `glimpse` function from **dplyr** package [@dplyr].\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrtr.train %>% glimpse()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 28\nColumns: 7\n$ chl         <dbl> 0.44, 0.37, 0.25, 0.23, 0.47, 0.68, 0.45, 0.28, 0.33, 0.63~\n$ temperature <dbl> 27.3, 27.0, 29.8, 28.9, 28.2, 28.2, 25.8, 27.2, 27.2, 29.2~\n$ do          <dbl> 6.19, 6.15, 5.32, 5.56, 6.35, 5.36, 5.76, 5.46, 6.10, 5.12~\n$ ph          <dbl> 7.85, 7.68, 8.30, 7.98, 7.87, 8.04, 8.02, 8.05, 7.80, 7.97~\n$ ammonia     <dbl> 0.88, 0.56, 0.61, 1.32, 0.56, 0.14, 0.56, 0.52, 0.65, 0.66~\n$ phosphate   <dbl> 0.92, 0.28, 0.51, 0.30, 0.28, 0.26, 0.17, 0.14, 0.43, 0.54~\n$ nitrate     <dbl> 0.64, 0.06, 0.03, 0.04, 0.03, 0.05, 0.05, 0.04, 0.48, 0.20~\n```\n:::\n:::\n\n\nThe printed output shows that we have seven variables and all are numeric\n\n# recipe\n\nThe **recipes** package [@recipes] define a recipe object that we will use for modeling and to conduct preprocessing of variables. The four main functions are `recipe()`, `prep()`, `juice()` and `bake()`. `recipe()` defines the operations on the data and the associated roles. Once the preprocessing steps are defined, any parameters are estimated using `prep()`. \n\nRecipes can be created manually by sequentially adding roles to variables in a data set. First, we will create a recipe object from the train set data and then specify the processing steps and transform the data with `step_*`. once the recipe is ready we prep it. For example, to create a simple recipe containing only an outcome and predictors and have the predictors normalized and missing values in predictors imputed:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrtr.recipe = crtr.train %>%\n  recipe(chl ~ .) %>%\n  step_normalize(all_numeric()) %>%\n  step_corr(all_numeric())%>%\n  step_impute_knn(all_numeric()) %>%\n  prep()\n\ncrtr.recipe\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRecipe\n\nInputs:\n\n      role #variables\n   outcome          1\n predictor          6\n\nTraining data contained 28 data points and no missing data.\n\nOperations:\n\nCentering and scaling for temperature, do, ph, ammonia, phosphate, nitrat... [trained]\nCorrelation filter on <none> [trained]\nK-nearest neighbor imputation for temperature, do, ph, ammonia, phosphate, nitra... [trained]\n```\n:::\n:::\n\n\nOnce the data are ready for transformation, the `juices()` extract transformed training set while the `bake()` function create a new testing set.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrtr.training = crtr.recipe %>%\n  juice()\n\ncrtr.testing = crtr.recipe %>%\n  bake(crtr.test)\n```\n:::\n\n\n\n# Build Models\n## Random Forest\nWe begin by fitting a random forest model. \n\n### Make random forest model\nWe specify the model using the **parsnip** package [@parsnip]. This package provides a tidy, unified interface to models for a range of models without getting bogged down in the syntactical minutiae of the underlying packages. The **parsnip** package help us to specify ;\n\n+ the `type` of model e.g  **random forest**,\n+ the `mode` of the model whether is `regression` or `classification`\n+ the computational `engine` is the name of the R package.\n\nBased on the information above, we can use **parsnip** package to build our model as;\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrf.model = rand_forest() %>%\n  set_engine(engine = \"ranger\") %>%\n  set_mode(mode = \"regression\")\n\nrf.model\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRandom Forest Model Specification (regression)\n\nComputational engine: ranger \n```\n:::\n:::\n\n\n### Train random forest model\n\nOnce we have specified the model type, engine and mode, the model can be trained with the `fit` function. We simply parse into the fit the specified model and the transformed training set extracted from the prepped recipe. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrf.fit = rf.model %>%\n  fit(chl ~ ., data = crtr.training)\n```\n:::\n\n\n### predict with random forest\nTo get our predicted results, we use the `predict()` function to find the estimated chlorophyll-*a*. First, let’s generate the estimated chlorophyll-*a* values by simply parse the random forest model `rf.model` we specified and the transformed testing set we created from a prepped recipe. We also stitch the predicted values to the transformed train set with `bind_cols` function;\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrf.predict = rf.fit %>%\n  predict(crtr.testing) %>%\n  bind_cols(crtr.testing) \n\nrf.predict\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 13 x 8\n     .pred temperature      do     ph ammonia phosphate nitrate     chl\n     <dbl>       <dbl>   <dbl>  <dbl>   <dbl>     <dbl>   <dbl>   <dbl>\n 1 -0.143        0.407  0.624  -0.756  1.05     -0.485   -0.364 -0.685 \n 2 -0.0964      -0.897  0.603  -1.56   0.401    -0.242   -0.419 -0.0561\n 3 -0.0919      -0.897  0.516  -1.20   0.530     0.0808   1.32   0.206 \n 4  0.366       -1.10   1.69   -1.64   0.562     1.86     3.49  -0.894 \n 5 -0.0544      -0.966  1.30   -0.976 -0.0507   -0.565   -0.364 -0.161 \n 6 -0.0748      -1.58  -0.0480 -1.12   0.498     0.0808   1.26  -1.31  \n 7  0.0753      -1.58   1.17   -0.462  2.05     -0.525    0.721  0.573 \n 8  0.160        0.887  0.538   0.493 -0.244     0.121   -0.473 -0.528 \n 9  0.189        0.887  0.429   0.420 -0.890    -0.202    0.341 -0.528 \n10 -0.0890       0.132 -0.850   0.567 -1.54     -0.767   -0.419 -0.632 \n11 -0.386        0.613 -0.200   0.567  0.272    -0.767   -0.364 -0.423 \n12 -0.0471       1.09  -0.503   0.714  1.66     -0.162   -0.419 -0.528 \n13  0.800        1.16   0.386   1.67   0.0138    2.10    -0.419  2.09  \n```\n:::\n:::\n\nWhen making predictions, the tidymodels convention is to always produce a tibble of results with standardized column names. This makes it easy to combine the original data and the predictions in a usable format:\n\n### Evaluate the rf model\n\nSo far, we have built a model and preprocessed data with a recipe. We predicted new data as a way to bundle a parsnip model and recipe together. The next step is to assess or evaluate the accuracy of the model. We use a `metrics` function from **yardstick** package [@yardstick]to assess the accuracy of the model by comparing the predicted versus the original outcome variable. Note that we use the predicted dataset we just computed using `predict` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrf.predict %>%\n  metrics(truth = chl, estimate = .pred)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 3\n  .metric .estimator .estimate\n  <chr>   <chr>          <dbl>\n1 rmse    standard       0.731\n2 rsq     standard       0.363\n3 mae     standard       0.595\n```\n:::\n:::\n\n\n\n## Linear regression approach\n### Make linear model\n\nThe good of **tidymodels** is that when we change the model, we do not need to start over again from the beginning but rather change the engine. For instance, we replace the `ranger` engine with `lm` to specify the linear model using the **parsnip** package [@parsnip] .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm.model = linear_reg() %>%\n  set_engine(engine = \"lm\") %>%\n  set_mode(mode = \"regression\")\n```\n:::\n\n\n### Train Linear model\nOnce we have specified the model type, engine and mode, the model can be trained with the `fit` function;\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm.fit = lm.model %>%\n  fit(chl ~ ., data = crtr.training)\n```\n:::\n\n\n### Predict with linear model\nOnce the model is fitted, This fitted object lm_fit has the lm model output built-in, which you can access with lm_fit$fit, but there are some benefits to using the fitted parsnip model object when it comes to predicting. To predict the values we use `predict` function and parse the model and standardized testing values we computed from the recipe [@r]. Note that here we use the transformed test set and not the original from the split object.  In this case we use the model to predict the value and stitch the testing values using the `bind_cols` function; \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm.predict = lm.fit %>%\n  predict(crtr.testing) %>%\n  bind_cols(crtr.testing) \n\nlm.predict\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 13 x 8\n     .pred temperature      do     ph ammonia phosphate nitrate     chl\n     <dbl>       <dbl>   <dbl>  <dbl>   <dbl>     <dbl>   <dbl>   <dbl>\n 1 -0.347        0.407  0.624  -0.756  1.05     -0.485   -0.364 -0.685 \n 2 -0.239       -0.897  0.603  -1.56   0.401    -0.242   -0.419 -0.0561\n 3 -0.260       -0.897  0.516  -1.20   0.530     0.0808   1.32   0.206 \n 4  0.0430      -1.10   1.69   -1.64   0.562     1.86     3.49  -0.894 \n 5 -0.238       -0.966  1.30   -0.976 -0.0507   -0.565   -0.364 -0.161 \n 6 -0.243       -1.58  -0.0480 -1.12   0.498     0.0808   1.26  -1.31  \n 7 -0.614       -1.58   1.17   -0.462  2.05     -0.525    0.721  0.573 \n 8  0.142        0.887  0.538   0.493 -0.244     0.121   -0.473 -0.528 \n 9  0.0942       0.887  0.429   0.420 -0.890    -0.202    0.341 -0.528 \n10  0.115        0.132 -0.850   0.567 -1.54     -0.767   -0.419 -0.632 \n11 -0.191        0.613 -0.200   0.567  0.272    -0.767   -0.364 -0.423 \n12 -0.215        1.09  -0.503   0.714  1.66     -0.162   -0.419 -0.528 \n13  0.760        1.16   0.386   1.67   0.0138    2.10    -0.419  2.09  \n```\n:::\n:::\n\n\n### Evaluate linear model\n\nOnce we have our `lm.predict` dataset that contains the predicted and test values, we can now use the `metrics` fiction to evaluate the accuracy of the model. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm.predict%>%\n  metrics(truth = chl, estimate = .pred)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 3\n  .metric .estimator .estimate\n  <chr>   <chr>          <dbl>\n1 rmse    standard       0.740\n2 rsq     standard       0.194\n3 mae     standard       0.629\n```\n:::\n:::\n\n\n### Estimate stats\nSometimes you may wish to plot predicted values with different predictors. To do that you need to create a new tidied data from the the model with `tidy` function and parse `interval = TRUE` argument as shown in the code below. This create a tibble shown below and the same data is plotted in figure \\@ref(fig:fig3).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlm.fit.stats = lm.fit %>% \n  tidy(interval = TRUE)\n\nlm.fit.stats\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 x 5\n  term         estimate std.error statistic p.value\n  <chr>           <dbl>     <dbl>     <dbl>   <dbl>\n1 (Intercept) -3.41e-17     0.200 -1.71e-16   1    \n2 temperature  1.29e- 2     0.253  5.09e- 2   0.960\n3 do          -2.09e- 2     0.261 -8.00e- 2   0.937\n4 ph           6.88e- 2     0.289  2.38e- 1   0.814\n5 ammonia     -1.63e- 1     0.235 -6.96e- 1   0.494\n6 phosphate    2.91e- 1     0.277  1.05e+ 0   0.306\n7 nitrate     -6.99e- 2     0.316 -2.21e- 1   0.827\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlm.fit.stats %>%\n  slice(-1) %>%\n  ggplot(aes(x = term, y = estimate)) +\n  geom_point(size = 4)+\n  geom_errorbar(aes(ymin = estimate-std.error, ymax = estimate+std.error), width = .2)+\n  scale_y_continuous(breaks = seq(-1.5,1.5,0.5))+\n  ggpubr::theme_pubclean()+\n  theme(axis.text = element_text(size = 10))+\n  labs(x = \"\", y = \"Estimated chl\")\n```\n\n::: {.cell-output-display}\n![Estimated value of chlorophyll concentration at different predictors](index_files/figure-html/fig-fig3-1.png){#fig-fig3 width=672}\n:::\n:::\n\n\n\n## Bayesian approach\n\n\n\n### Make Bayes Model\nFor Bayesian, we also change the engine and specified are called `prior` and `prior_intercept`. It turns out that `linear_reg()` has a `stan` engine. Since these prior distribution arguments are specific to the Stan software, they are passed as arguments to `parsnip::set_engine()`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprior.dist = rstanarm::student_t(df = 1)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(401)\n\n## make the parsnip model\nbayes.model = linear_reg() %>%\n  set_engine(engine = \"stan\", \n             prior_intercept = prior.dist, \n             prior = prior.dist) %>%\n  set_mode(mode = \"regression\")\n```\n:::\n\n\nThis kind of Bayesian analysis (like many models) involves randomly generated numbers in its fitting procedure. We can use `set.seed()` to ensure that the same (pseudo-)random numbers are generated each time we run this code. The number 123 isn’t special or related to our data; it is just a “seed” used to choose random numbers.\n\n### Train Bayes model\nOnce we have defined the Bayesian model, we train it using a transformed testing set;\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## train the bayes model\nbayes.fit = bayes.model%>%\n  fit(chl ~ ., data = crtr.testing)\n\nbayes.fit\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nparsnip model object\n\nstan_glm\n family:       gaussian [identity]\n formula:      chl ~ .\n observations: 13\n predictors:   7\n------\n            Median MAD_SD\n(Intercept) -0.2    0.2  \ntemperature -0.5    0.3  \ndo           0.4    0.4  \nph           0.6    0.4  \nammonia      0.1    0.2  \nphosphate    0.6    0.3  \nnitrate     -0.5    0.3  \n\nAuxiliary parameter(s):\n      Median MAD_SD\nsigma 0.7    0.2   \n\n------\n* For help interpreting the printed output see ?print.stanreg\n* For info on the priors used see ?prior_summary.stanreg\n```\n:::\n:::\n\n\n\n### Predict Bayes fit\n\n::: {.cell}\n\n```{.r .cell-code}\nbayes.predict = bayes.fit %>%\n  predict(crtr.testing) %>%\n  bind_cols(crtr.testing)\n\nbayes.predict\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 13 x 8\n     .pred temperature      do     ph ammonia phosphate nitrate     chl\n     <dbl>       <dbl>   <dbl>  <dbl>   <dbl>     <dbl>   <dbl>   <dbl>\n 1 -0.607        0.407  0.624  -0.756  1.05     -0.485   -0.364 -0.685 \n 2 -0.302       -0.897  0.603  -1.56   0.401    -0.242   -0.419 -0.0561\n 3 -0.827       -0.897  0.516  -1.20   0.530     0.0808   1.32   0.206 \n 4 -0.617       -1.10   1.69   -1.64   0.562     1.86     3.49  -0.894 \n 5  0.0850      -0.966  1.30   -0.976 -0.0507   -0.565   -0.364 -0.161 \n 6 -0.611       -1.58  -0.0480 -1.12   0.498     0.0808   1.26  -1.31  \n 7  0.379       -1.58   1.17   -0.462  2.05     -0.525    0.721  0.573 \n 8  0.0950       0.887  0.538   0.493 -0.244     0.121   -0.473 -0.528 \n 9 -0.686        0.887  0.429   0.420 -0.890    -0.202    0.341 -0.528 \n10 -0.705        0.132 -0.850   0.567 -1.54     -0.767   -0.419 -0.632 \n11 -0.516        0.613 -0.200   0.567  0.272    -0.767   -0.364 -0.423 \n12 -0.256        1.09  -0.503   0.714  1.66     -0.162   -0.419 -0.528 \n13  1.74         1.16   0.386   1.67   0.0138    2.10    -0.419  2.09  \n```\n:::\n:::\n\n\n### Evaluate Bayes model\n\n::: {.cell}\n\n```{.r .cell-code}\nbayes.predict %>%\n  metrics(truth = chl, estimate = .pred)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 x 3\n  .metric .estimator .estimate\n  <chr>   <chr>          <dbl>\n1 rmse    standard       0.432\n2 rsq     standard       0.717\n3 mae     standard       0.334\n```\n:::\n:::\n\n\n\n### Bayes.fit.stats\nTo update the parameter table, the `tidy()` method is once again used:\n\n::: {.cell}\n\n```{.r .cell-code}\nbayes.stats = bayes.fit %>% \n  broom.mixed::tidy(intervals = TRUE)\n\nbayes.stats\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 7 x 3\n  term        estimate std.error\n  <chr>          <dbl>     <dbl>\n1 (Intercept)   -0.220     0.230\n2 temperature   -0.541     0.338\n3 do             0.394     0.370\n4 ph             0.597     0.379\n5 ammonia        0.120     0.222\n6 phosphate      0.586     0.310\n7 nitrate       -0.527     0.270\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbayes.stats %>% \n  slice(-1) %>%\n  ggplot(aes(x = term, y = estimate)) +\n  geom_point(size = 4)+\n  geom_errorbar(aes(ymin = estimate - std.error, ymax = estimate + std.error), width = .2)+\n  scale_y_continuous(breaks = seq(-1.5,1.5,0.5))+\n  ggpubr::theme_pubclean()+\n  theme(axis.text = element_text(size = 10))+\n  labs(x = \"\", y = \"Estimated chl\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n\n## Links\n\n+ [Machine Learning with tidymodels](http://www.wvview.org/os_sa/20_tidymodels.html)\n\n\n## Cited Materials\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}